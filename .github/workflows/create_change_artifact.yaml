name: Create change-artifact suggestion

on:
  pull_request:

permissions:
  contents: read
  pull-requests: write

jobs:
  check_and_suggest:
    if: ${{ github.event.pull_request.user.type != 'Bot' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5.0.0

      - name: Setup Node.js
        uses: actions/setup-node@v6.0.0
        with:
          node-version: '18'

      - name: Install js-yaml
        run: npm install js-yaml --no-audit --no-fund --no-save

      - name: Parse PR and suggest change artifact
        uses: actions/github-script@v8.0.0
        with:
          script: |
            const yaml = require('js-yaml');
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed('No pull_request found in context');
              return;
            }

            const body = pr.body || '';
            const sectionMatch = body.match(/### Information for the change artifact\s*([\s\S]*?)(?:\n###|\n$)/i);
            const section = sectionMatch ? sectionMatch[1] : '';

            function extractField(name) {
              const re = new RegExp('^\\s*' + name.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\$&') + ':\\s*(.*)$', 'mi');
              const m = section.match(re);
              return m ? m[1].trim() : '';
            }

            const type = extractField('Type');
            const description = extractField('Description');
            const related_issue = extractField('Related GitHub issue');
            const visibility = extractField('Visibility');
            const highlight_raw = extractField('Highlight');

            // Validate required fields
            const missing = [];
            if (!type) missing.push('Type');
            if (!description) missing.push('Description');
            if (!visibility) missing.push('Visibility');
            if (!highlight_raw) missing.push('Highlight');
            if (missing.length) {
              core.setFailed('Missing required change-artifact fields: ' + missing.join(', '));
              return;
            }

            const highlight = /^true$/i.test(highlight_raw) ? true : (/^false$/i.test(highlight_raw) ? false : highlight_raw);

            // Only populate related_issue when it's a full URL (http(s)://...)
            const relatedIssueUrl = /^https?:\/\//i.test(related_issue || null) ? related_issue.trim() : null;

            const artifactObj = {
              version_schema: 1,
              changes: [
                {
                  title: pr.title || '',
                  author: pr.user && pr.user.login ? pr.user.login : '',
                  type: type,
                  description: description,
                  urls: {
                    pr: pr.html_url || null,
                    related_doc: null,
                    related_issue: relatedIssueUrl
                  },
                  visibility: visibility,
                  highlight: highlight
                }
              ]
            };

            // YAML string for suggestion
            let suggestedYaml = yaml.dump(artifactObj, { noRefs: true, lineWidth: -1 });

            // Ensure `related_doc` appears without an explicit empty string or `null` value
            suggestedYaml = suggestedYaml.replace(/\n(\s*)related_doc:\s*(?:''|"")/g, '\n$1related_doc:');
            suggestedYaml = suggestedYaml.replace(/\n(\s*)related_doc:\s*null/g, '\n$1related_doc:');

            // Compute zero-padded filename
            const prNumber = pr.number;
            const padded = String(prNumber).padStart(4, '0');
            const path = `docs/release-notes/artifacts/pr${padded}.yaml`;

            // Helper to deep-sort object keys for stable comparison
            function sortObject(o) {
              if (Array.isArray(o)) return o.map(sortObject);
              if (o && typeof o === 'object') {
                const sorted = {};
                Object.keys(o).sort().forEach(k => {
                  sorted[k] = sortObject(o[k]);
                });
                return sorted;
              }
              return o;
            }

            // Check for existing file on default branch
            const defaultBranch = context.payload.repository.default_branch || 'main';
            let existing = null;
            try {
              const res = await github.rest.repos.getContent({ owner, repo, path, ref: defaultBranch });
              const content = Buffer.from(res.data.content, 'base64').toString('utf8');
              existing = content;
            } catch (err) {
              // not found -> continue as new file
              if (err.status && err.status === 404) {
                existing = null;
              } else {
                throw err;
              }
            }

            if (existing) {
              let existingObj = null;
              try {
                existingObj = yaml.load(existing);
              } catch (e) {
                // If existing YAML can't be parsed, treat as different
                existingObj = null;
              }

              const a = sortObject(artifactObj);
              const b = existingObj ? sortObject(existingObj) : null;

              if (b && JSON.stringify(a) === JSON.stringify(b)) {
                const msg = `Found existing artifact file at \`${path}\` that matches PR content. No changes suggested.`;
                await github.rest.pulls.createReview({ owner, repo, pull_number: prNumber, body: msg, event: 'COMMENT' });
                core.info(msg);
                return;
              }
            }

            // Prepare suggestion body
            const header = existing ? `Suggested edits to existing file \`${path}\`:` : `Suggested new file \`${path}\`:`;
            const finalBody = header + "\n\n" + "```yaml\n" + suggestedYaml + "```\n\n" +
              (existing ? '_This will update the existing artifact with the PR information._' : '_This will add the artifact file based on the PR information._');

            await github.rest.pulls.createReview({ owner, repo, pull_number: prNumber, body: finalBody, event: 'COMMENT' });
            core.info('Posted suggestion review for ' + path);
